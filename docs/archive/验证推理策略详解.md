# 验证推理策略详解

## 1. 训练vs验证的裁剪策略差异

### 训练时 (split == "train")
```python
# 训练时使用随机裁剪
if split == "train":
    crop_size = 256
    # 随机裁剪增加数据多样性，提高泛化能力
```

**训练裁剪的特点：**
- **随机性**：每次训练时裁剪位置不同，增加数据多样性
- **小尺寸**：256x256便于GPU内存管理和训练效率
- **数据增强**：通过随机裁剪模拟不同场景，提高模型鲁棒性

### 验证时 (split == "val")
```python
# 验证时保持原始尺寸
if split == "val":
    crop_size = None  # 不裁剪，保持原始尺寸
```

**验证不裁剪的原因：**
1. **真实评估**：保持原始分辨率，评估模型在真实场景下的性能
2. **一致性**：避免随机性影响评估结果的可重复性
3. **完整性**：保留完整图像信息，不丢失边缘细节

## 2. 验证时裁剪的注意事项

如果验证时也需要裁剪，应该注意：

### 2.1 确定性裁剪
```python
# 使用中心裁剪而非随机裁剪
def center_crop(image, crop_size):
    h, w = image.shape[-2:]
    start_h = (h - crop_size) // 2
    start_w = (w - crop_size) // 2
    return image[..., start_h:start_h+crop_size, start_w:start_w+crop_size]
```

### 2.2 多尺度评估
```python
# 在不同尺度下评估
scales = [256, 512, 1024]
for scale in scales:
    cropped = center_crop(image, scale)
    result = model(cropped)
```

### 2.3 重叠区域处理
```python
# 使用重叠裁剪减少边界效应
def overlapping_crop(image, crop_size, overlap=64):
    # 实现重叠裁剪逻辑
    pass
```

## 3. Tile Inference 原理详解

### 3.1 基本概念
Tile Inference是将大图像分割成小块进行推理的方法：

```python
def tile_inference(model, blur, spike_vox, tile_size=256, tile_overlap=64):
    """
    Args:
        model: 训练好的模型
        blur: 模糊图像 [B, C, T, H, W]
        spike_vox: 脉冲体素 [B, C, T, H_s, W_s]
        tile_size: 每个tile的尺寸
        tile_overlap: tile之间的重叠区域
    """
```

### 3.2 核心步骤

#### 步骤1: 计算tile网格
```python
# 计算需要的tile数量
stride = tile_size - tile_overlap
h_tiles = (H - tile_overlap + stride - 1) // stride
w_tiles = (W - tile_overlap + stride - 1) // stride
```

#### 步骤2: 创建权重图
```python
# 创建cosine窗函数用于平滑融合
tile_weight = torch.ones(1, 1, 1, tile_size, tile_size)
if tile_overlap > 0:
    fade = torch.linspace(0, 1, tile_overlap)
    fade_window = torch.cos((1 - fade) * torch.pi / 2)
    # 应用到四个边缘
    tile_weight[:, :, :, :tile_overlap, :] *= fade_window.view(1, 1, 1, -1, 1)
    # ... 其他边缘
```

#### 步骤3: 逐tile处理
```python
for i in range(h_tiles):
    for j in range(w_tiles):
        # 计算tile坐标
        h_start = i * stride
        w_start = j * stride
        h_end = min(h_start + tile_size, H)
        w_end = min(w_start + tile_size, W)
        
        # 提取tile
        blur_tile = blur[:, :, :, h_start:h_end, w_start:w_end]
        spike_vox_tile = spike_vox[:, :, :, h_s_start:h_s_end, w_s_start:w_s_end]
        
        # 推理
        recon_tile = model(blur_tile, spike_vox_tile)
        
        # 加权累加
        output[:, :, :, h_start:h_end, w_start:w_end] += recon_tile * current_weight
        weight[:, :, :, h_start:h_end, w_start:w_end] += current_weight
```

#### 步骤4: 归一化融合
```python
# 按权重归一化
output = output / (weight + 1e-8)
```

### 3.3 优势与挑战

**优势：**
- **内存友好**：避免大图像导致的内存溢出
- **灵活性**：可以处理任意尺寸的图像
- **并行性**：tile之间可以并行处理

**挑战：**
- **边界效应**：tile边界可能出现伪影
- **计算开销**：重叠区域导致重复计算
- **融合质量**：权重融合可能影响最终质量

## 4. 其他主流推理方法

### 4.1 滑动窗口 (Sliding Window)
```python
def sliding_window_inference(model, image, window_size, stride):
    """滑动窗口推理"""
    results = []
    for y in range(0, image.height - window_size + 1, stride):
        for x in range(0, image.width - window_size + 1, stride):
            window = image[y:y+window_size, x:x+window_size]
            result = model(window)
            results.append((x, y, result))
    return merge_results(results)
```

**特点：**
- 固定步长滑动
- 适用于目标检测、分割任务
- 计算量大但结果稳定

### 4.2 多尺度推理 (Multi-scale)
```python
def multi_scale_inference(model, image, scales=[0.5, 1.0, 1.5]):
    """多尺度推理"""
    results = []
    for scale in scales:
        scaled_image = resize(image, scale)
        result = model(scaled_image)
        results.append(resize(result, 1/scale))
    return fuse_multi_scale(results)
```

**特点：**
- 提高对不同尺寸目标的检测能力
- 计算成本高
- 需要后处理融合

### 4.3 金字塔推理 (Pyramid)
```python
def pyramid_inference(model, image, levels=3):
    """金字塔推理"""
    pyramid = build_pyramid(image, levels)
    results = []
    for level in pyramid:
        result = model(level)
        results.append(result)
    return reconstruct_from_pyramid(results)
```

**特点：**
- 从粗到细的处理
- 适合多尺度特征提取
- 计算复杂度高

### 4.4 全图推理 (Full Image)
```python
def full_image_inference(model, image):
    """全图推理"""
    # 直接处理整个图像
    return model(image)
```

**特点：**
- 最简单直接
- 需要足够的内存
- 可能丢失细节信息

## 5. 方法选择指南

### 5.1 根据任务选择
- **图像复原**：Tile Inference + 重叠融合
- **目标检测**：滑动窗口 + NMS
- **语义分割**：Tile Inference + 重叠融合
- **超分辨率**：Tile Inference + 边缘处理

### 5.2 根据资源选择
- **内存充足**：全图推理
- **内存受限**：Tile Inference
- **计算受限**：中心裁剪
- **精度优先**：多尺度推理

### 5.3 根据图像尺寸选择
- **小图像 (<512px)**：全图推理
- **中等图像 (512-2048px)**：Tile Inference
- **大图像 (>2048px)**：多尺度 + Tile Inference

## 6. 实际应用建议

### 6.1 验证策略
```python
def validation_strategy(image_size, gpu_memory):
    if image_size < 512:
        return "full_image"
    elif gpu_memory > 8:
        return "tile_inference"
    else:
        return "center_crop"
```

### 6.2 参数调优
```python
# Tile Inference 参数建议
tile_size = min(256, gpu_memory_limit)
tile_overlap = tile_size // 4  # 25% 重叠
stride = tile_size - tile_overlap
```

### 6.3 质量评估
```python
def evaluate_inference_method(method, test_images):
    """评估不同推理方法的质量"""
    metrics = {}
    for method_name, method_func in method.items():
        results = []
        for img in test_images:
            result = method_func(img)
            metrics[method_name] = calculate_metrics(result, img.gt)
    return metrics
```

## 7. 总结

1. **训练裁剪**：随机裁剪增加多样性，提高泛化能力
2. **验证策略**：保持原始尺寸或使用确定性裁剪
3. **Tile Inference**：内存友好的大图像处理方法
4. **方法选择**：根据任务、资源、图像尺寸综合考虑
5. **质量保证**：通过重叠融合和权重归一化保证结果质量

选择合适的推理策略需要在计算效率、内存使用、结果质量之间找到平衡点。