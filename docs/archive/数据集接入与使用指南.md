Cursor 按本文逐条落地即可，无需自行决策或“优化想象”。

---

# GoPro-Spike 合成数据集接入与使用指南（Cursor 执行版）

## 1. 适用范围与最终目标（必须达成）

* 目标数据：**Synthetic Spike Dataset Based on GoPro Dataset**（你已给出 train/test 目录树与 `.dat`/`.png` 对应关系）
* 目标系统：以 VRT 为 backbone 的**视频去模糊**任务；输入包含 RGB 模糊序列与同时间窗的 **spike 体素序列**（K=32 默认）
* 关键约束：

  1. **曝光时间窗严格对齐**（模糊帧由 33 帧等权积分/平均而来，FPS=1000）；
  2. Spike 分辨率若与 RGB 不一致，**先空间对齐**再体素化；
  3. 体素化后，**log1p → 训练集统计 mean/std 标准化**；
  4. DataLoader 统一契约：`{'blur': [B,T,3,H,W], 'sharp': [B,T,3,H,W], 'spike_vox':[B,T,K,H,W]}`；
  5. 融合位点固定在 **每层 TMSA 之前的 Concat→1×1**。

> 上述基线约束与我们既有的数据接入规范一致，不得更改。&#x20;

---

## 2. 目录与文件放置（固定，不得变更）

### 2.1 仓库内项目结构（只新增，不破坏既有结构）

```
repo_root/
├─ data/
│  ├─ raw/
│  │  └─ gopro_spike/                 # <== 把你解压后的原始数据放这里（见 2.2）
│  ├─ processed/
│  │  └─ gopro_spike/
│  │     └─ spike_vox/                # prepare_data.py 生成的 K×H×W .npy
│  └─ tmp/
├─ src/
│  └─ data/
│     ├─ vendors/
│     │  └─ gopro/                    # 供应方脚本的“只读封装层”
│     │     ├─ original/              # 原样放置（严禁改动）
│     │     │  ├─ deblur_gopro_sequence.py
│     │     │  ├─ deblur_gopro_dataset.py
│     │     │  └─ deblur_read_gopro_test_data.py
│     │     └─ io_gopro.py            # 我们的薄封装（统一对外接口，见 3.1）
│     ├─ datasets/
│     │  ├─ spike_deblur_dataset.py   # （你项目既有文件）读取 .npy + RGB 组装 clip
│     │  └─ voxelizer.py              # （你项目既有文件）体素化实现，若已存在按本文使用
│     └─ collate_fns.py
├─ scripts/
│  └─ prepare_data.py                  # 数据扫描/对齐/体素化/标准化/缓存
└─ configs/
   └─ deblur/
      └─ vrt_spike_baseline.yaml       # 统一配置（DATA.ROOT/K/CLIP_LEN/NORM）
```

> 三份**示例代码**必须**原样**放在 `src/data/vendors/gopro/original/`（只读），由 `io_gopro.py` 进行最小层的调用封装。 &#x20;

### 2.2 原始数据放置（完全按你提供的目录树）

把解压后的 **GOPRO\_Large** 与 **GOPRO\_Large\_spike\_seq**（含 train/test 两套）整个复制到：

```
repo_root/data/raw/gopro_spike/
├─ GOPRO_Large/
│  ├─ train/…/blur, blur_gamma, sharp/*.png
│  └─ test /…/blur, blur_gamma, sharp/*.png
└─ GOPRO_Large_spike_seq/
   ├─ train/…/spike/*.dat
   └─ test /…/spike/*.dat
```

> 路径和命名**禁止**改动；`Scene`/子目录按原名保持一一对应关系。

---

## 3. 供应方示例的“只读封装”与统一接口

### 3.1 在 `io_gopro.py` 暴露**唯一**三函数（签名固定）

```python
# src/data/vendors/gopro/io_gopro.py
from pathlib import Path
import numpy as np
from typing import Tuple, List

def list_blur_frames_for_split(data_root: Path, split: str) -> List[Path]:
    """
    遍历 GOPRO_Large/<split>/**/blur_gamma/*.png
    返回按帧序排序的 PNG 绝对路径列表（逐帧为主键）。
    """

def load_spike_sequence(spike_dat_path: Path, Hs: int, Ws: int) -> np.ndarray:
    """
    复用 original/deblur_read_gopro_test_data.py 的 load_vidar_dat/TFI 逻辑，
    读取单个 .dat 为 (T, Hs, Ws) 的 uint8/0-1 序列（或经 TFI 的浮点图序列，见 3.3）。
    """

def spatial_align_to_rgb(spike_seq: np.ndarray, target_hw: Tuple[int, int]) -> np.ndarray:
    """
    若 spike (Hs, Ws) != RGB (H, W)，上采样到 target_hw（最近邻或双线性，任选其一并固定）。
    不执行归一化与体素化。
    """
```

> 这三函数是**唯一的读取出口**，其内部**直接 import** 供应方原脚本的解析函数，不复制实现。路径映射与分辨率取值遵循原脚本默认策略（例如 `Hs=360, Ws=640`，`H=720, W=1280`），**不要自造规则**。

### 3.2 路径映射规则（固定，不得更改）

* 由任意一张 `GOPRO_Large/<split>/<Scene>/<Sub>/blur_gamma/000XYZ.png`
  映射到其 spike：`GOPRO_Large_spike_seq/<split>/<Scene>/<Sub>/spike/000XYZ.dat`
* 同理，sharp：`GOPRO_Large/<split>/<Scene>/<Sub>/sharp/000XYZ.png`

> 此规则与示例 `Sequence`/`DatasetProvider` 的实现完全一致，必须照搬。&#x20;

### 3.3 关于 `load_vidar_dat/TFI` 的使用（按示例一致）

* 供应方示例提供了 `.dat` 的 bitplane 解包与 **TFI（Time to First Spike Interval）** 的计算；我们**只调用**它：

  * 若后续走**体素化**，`io_gopro.load_spike_sequence` 输出**原始 spike 帧序列** `(T,Hs,Ws)`（0/1）；
  * 若做 TFI 可视检查或对比，可额外调用示例里的 `TFI.spikes2images()` 获得浮点影像序列。
* `numba`/加速参数维持示例默认，不要修改。

---

## 4. `prepare_data.py`：自动扫描→对齐→体素化→标准化→缓存（一次定稿）

### 4.1 命令行（固定）

```bash
python scripts/prepare_data.py \
  --data-root data/raw/gopro_spike \
  --split train \
  --fps 1000 \
  --exposure-frames 33 \
  --K 32 \
  --resize-mode bilinear \
  --out-dir data/processed/gopro_spike/spike_vox \
  --log-file outputs/logs/align_gopro_spk_train.txt
```

> `split ∈ {train, test}`；若需 val，自行用 train 子集划分但路径规则不变。

### 4.2 扫描主键（逐帧）

* 以 `GOPRO_Large/<split>/**/blur_gamma/*.png` 为**唯一主键集合**；
* 逐帧做路径替换得到 spike `.dat` 与 sharp `.png` 的对应文件；找不到即**日志告警并跳过**。

### 4.3 时间窗与体素化（严格对齐）

* 约定：`FPS=1000`，模糊曝光长度 `e=33` 帧；对主键帧的中心时刻 `t_c`，曝光窗 `[t0, t1] = [t_c - 16, t_c + 16]`；
* 将 `[t0, t1]` **等分为 K=32 段**，对 spike 序列按段计数，得 `vox ∈ ℝ^{K×H×W}`；
* 若 spike `(Hs,Ws)` 与 RGB 不同，**先**对 `spike_seq` 进行空间上采样到 `(H,W)`，**后**再计数；
* 归一化：对 `vox` **先 `log1p`**，再按像素通道统计**训练集 mean/std** 并固化到配置。&#x20;

### 4.4 输出与日志（格式固定）

* 每帧生成：`data/processed/gopro_spike/spike_vox/<Scene>/<Sub>/<frame>.npy`（包含 `(K,H,W)`）；
* 同步记录一行 CSV 到 `--log-file`：

  ```
  split,scene,sub,frame,t0_idx,t1_idx,events
  ```

  其中 `events = vox.sum()`（或原始 spike 在窗内的和）。

---

## 5. Dataset / DataLoader 对接（训练与评测一致）

### 5.1 统一返回契约（固定）

`src/data/datasets/spike_deblur_dataset.py` 中，每次 `__getitem__` 返回：

```python
{
  'blur':      FloatTensor[B, T, 3, H, W],
  'sharp':     FloatTensor[B, T, 3, H, W],
  'spike_vox': FloatTensor[B, T, K, H, W],
  'meta': {
    'seq': str, 'frame_idx': List[int], 't0': List[int], 't1': List[int]
  }
}
```

* `T`（clip 长度）由 VRT 配置 `DATA.CLIP_LEN` 决定（默认 5）；
* `spike_vox` 来自 4.4 的 .npy；RGB 从 `blur_gamma` 与 `sharp` 读取；**三者在 (T,H,W) 完全对齐**。

> 这与我们既有“VRT+Spike 的输入契约”一致；`Sequence/Provider` 示例可作为组织参考，但实际读取以我们缓存 `.npy` 为准。&#x20;

### 5.2 配置文件（写死关键项）

`configs/deblur/vrt_spike_baseline.yaml`

```yaml
DATA:
  ROOT: "data/raw/gopro_spike"
  PROCESSED_ROOT: "data/processed/gopro_spike/spike_vox"
  K: 32
  CLIP_LEN: 5
  NORM:
    MEAN: [<prepare脚本写回的单值或每通道均值>]
    STD:  [<prepare脚本写回的单值或每通道方差>]
```

> MEAN/STD 由 `prepare_data.py` **统计并回写**，开发者不可手填拍脑袋数值。

---

## 6. 验收与可视化（强制执行的两项抽检）

1. **运动一致性检验**：随机抽 20 帧，将对应 `spike_vox.sum(axis=0)`（H×W）与 `blur` 做并排可视化，检查运动方向/边界是否一致；
2. **事件计数异常检验**：日志中 `events` 不得全 0，亦不得远超同 scene 同分辨率的常规数量级（>10×中位数）——出现则回溯该帧的映射与时间窗。

> 这两项是我们基线文档中的强制排查项，必须保留。

---

## 7. Cursor 逐条执行清单（勾完即完成）

* [ ] **拷入示例（只读）**：把三份示例脚本原样放入 `src/data/vendors/gopro/original/`。 &#x20;
* [ ] **实现 `io_gopro.py`**：仅实现 3 个对外函数；内部直接 `import original.*` 并转调。
* [ ] **实现 `scripts/prepare_data.py`**：精确按 4.1–4.4 的参数、流程与输出。
* [ ] **改造/确认 `spike_deblur_dataset.py`**：按 5.1 契约读取 `blur/sharp` 与 `.npy`，组装 (B,T,…) clip。
* [ ] **写入配置**：在 `configs/deblur/vrt_spike_baseline.yaml` 固定 `DATA.*`，运行 `prepare_data.py` 后把 `NORM.MEAN/STD` 写回。
* [ ] **执行验收**：完成两项可视与统计检查（第 6 节），不合格则阻断训练。

---

## 8. 常见问题（按本文答案处理；不得自由发挥）

**Q1：Spike 与 RGB 分辨率不一致怎么办？**
A：**先对 Spike 做空间上采样**到 RGB 的 (H,W)，再体素化；不要“体素化后再上采样”。

**Q2：是否允许替换 `.dat` 解析器或改写 TFI？**
A：不允许。必须**调用供应方示例**的 `load_vidar_dat/TFI` 逻辑，保持事实标准一致。

**Q3：Clip 的组装时序由谁决定？**
A：由 **Dataset** 依据 `DATA.CLIP_LEN` 从逐帧缓存 `.npy`/RGB 组装；`prepare_data.py` 只做**逐帧缓存**。

**Q4：标准化为什么要先 `log1p`？**
A：Spike 计数高度稀疏且重尾，`log1p` 稳定方差后再做 mean/std 更鲁棒；这是我们既有基线流程的一部分（不可改）。

---

## 9. 最小复现命令（照抄即可）

### 9.1 生成体素缓存

```bash
python scripts/prepare_data.py \
  --data-root data/raw/gopro_spike \
  --split train --fps 1000 --exposure-frames 33 --K 32 \
  --resize-mode bilinear \
  --out-dir data/processed/gopro_spike/spike_vox \
  --log-file outputs/logs/align_gopro_spk_train.txt
```

### 9.2 训练前检查（可选但推荐）

```bash
python -c "import numpy as np,glob;import random as r; f=r.choice(glob.glob('data/processed/gopro_spike/spike_vox/**/**/*.npy',recursive=True));\
v=np.load(f); print(f, v.shape, v.sum())"
```

### 9.3 启动训练（示意）

```bash
python train_vrt.py --config configs/deblur/vrt_spike_baseline.yaml
```

---

## 10. 与你上传示例代码的一致性声明（关键对齐点）

* **路径映射**与**分辨率默认值**：完全遵循 `Sequence/Provider` 的实现与分辨率字典（720×1280 与 360×640 的对应）。&#x20;
* **.dat 解析与 TFI**：严格调用 `deblur_read_gopro_test_data.py` 中的 `load_vidar_dat/TFI`，含 `numba` 加速路径。
* **体素化/标准化/融合位点**：执行我们基线文档的固定流程与插点（TMSA 前 Concat→1×1）。&#x20;

---

### 结语

以上文本即为**唯一权威的实施手册**。Cursor **逐条照做**即可完成 GoPro-Spike 数据的接入、体素缓存生成、Dataset 对接与训练前验收；过程中**不得**更改目录、命名、参数、流程与位点。若发现任何与示例实现不一致之处，**以本文与示例代码为准**（示例仅能被调用，不得修改）。
